import type * as PM from "@lib/devenv/ProjectModel"
import {createProjectModel} from "@lib/devenv/createProjectModel"
import ts from "typescript"
import fs from "node:fs"
import path from "node:path"
import * as esbuild from "esbuild"

export class Build {
  constructor(props: {}) {}

  async run() {
    const model = await createProjectModel({})
    await this.runTsc(model)
    await this.runEsbuild(model)

    return model
  }

  // Run the typescript compiler to do type-checking, and to generate
  // .d.ts files that will later be used by rollup to generate the
  // final lib.d.ts
  async runTsc(model: PM.ProjectModel): Promise<ts.EmitResult> {
    // Prepare to run tsc
    const tsconfig = this.generateTsconfig(model)
    const config = ts.parseJsonConfigFileContent(
      tsconfig,
      ts.sys,
      model.projectRoot
    )
    const program = ts.createProgram(config.fileNames, config.options)

    // Run tsc, capture errors
    const emitResult = program.emit()
    const allDiagnostics = ts
      .getPreEmitDiagnostics(program)
      .concat(emitResult.diagnostics)
    if (allDiagnostics.length > 0) {
      const formatted = ts.formatDiagnosticsWithColorAndContext(
        allDiagnostics,
        ts.createCompilerHost(config.options)
      )
      console.error(formatted)
    }

    // Throw if there are any errors
    const hasErrors = allDiagnostics.some(
      (d) => d.category === ts.DiagnosticCategory.Error
    )
    if (hasErrors) {
      throw new Error("TypeScript compilation failed with errors.")
    }

    return emitResult
  }

  generateTsconfigPaths(): Record<string, Array<string>> {
    return {}
  }

  generateEsbuildTsconfigRaw(): esbuild.TsconfigRaw {
    return {
      compilerOptions: {
        jsx: "preserve",
        paths: this.generateTsconfigPaths(),
        strict: true,
        target: "esnext",
      },
    }
  }

  generateTsconfig(model: PM.ProjectModel): TsconfigJson {
    const {projectRoot} = model
    const libTypesFile = model.features.lib?.libTypesFile
    const generateTypes = libTypesFile != null

    // Additional options and files to add depending on whether we're
    // generating .d.ts files or not
    const generateOptions = generateTypes
      ? {
          outDir: "./build/tsc",
          declaration: true,
          emitDeclarationOnly: true,
          declarationDir: "./build/tsc",
        }
      : {
          noEmit: true,
        }

    const compilerOptions: ts.CompilerOptions = {
      baseUrl: ".",

      // Module resolution and code generation
      moduleResolution: ts.ModuleResolutionKind.Bundler,
      module: ts.ModuleKind.ESNext,
      esModuleInterop: true,
      jsx: ts.JsxEmit.Preserve,
      target: ts.ScriptTarget.ESNext,
      paths: this.generateTsconfigPaths(),

      // For type-generation, or no generation
      ...generateOptions,

      // linting features
      strict: true,
      exactOptionalPropertyTypes: false,
      noFallthroughCasesInSwitch: true,
      noImplicitOverride: true,
      noImplicitReturns: true,
      noPropertyAccessFromIndexSignature: true,
      noUncheckedIndexedAccess: true,
      noUncheckedSideEffectImports: true,
      resolveJsonModule: true,
      allowJs: true,
      checkJs: true,
      isolatedModules: true,
    }

    // Sometimes the "lib-types.ts" file needs to be included
    // explicitly, otherwise tsc might not generate its .d.ts file if
    // it only contains types
    const generateInclude = generateTypes ? [libTypesFile] : []
    const include = [...generateInclude, "./src/**/*", "./test/**/*"]

    return {
      compilerOptions,
      include,
    }
  }

  // Run esbuild to generate all of the bundles (except for the ones
  // that will be generated by vite)
  async runEsbuild(model: PM.ProjectModel) {
    const {projectRoot} = model
    const libFile = model.features.lib?.libFile

    // generate the metafile that tracks what was bundled and why
    // FIXME - make this configurable
    const generateMetafile = false

    const builds: Array<EsbuildTarget> = []
    if (libFile != null) {
      builds.push({
        entry: libFile,
        out: path.join(projectRoot, "dist", "lib", "lib.es.js"),
        format: "esm",
      })
    }

    const tsconfig = this.generateEsbuildTsconfigRaw()

    //      { entry: "src/lib.ts", out: "dist/lib/lib.es.js", format: "esm" },
    // { entry: "src/cli/cli.ts", out: "dist/cli/cli.es.js", format: "esm" },
    // // FIXME - have it scan through the webapps directory automatically
    // {
    //   entry: "src/webapps/main/server/WebappLambda.ts",
    //   out: "dist/webapp-servers/main/webapp-lambda/WebappLambda.cjs",
    //   format: "cjs",
    //   isLambda: true,
    // },
    // { entry: "test/tests.ts", out: "build/test/tests.es.js", format: "esm" },

    // In the node environment, the generated client can't be bundled with
    // the application code, otherwise it results in errors like 'Error:
    // Dynamic require of "node:fs" is not supported'.  To get around
    // this, we need esbuild to not include this code, but still be able
    // to access it at runtime.  The only way I've found to do this is:
    //
    //   * have prisma generate the files directly into node_modules
    //   * have the TS files import "prisma-app-client/{service}/index.js"
    //   * have esbuild exclude "prisma-app-client" from the bundle
    const prismaExcludes = ["@prisma/client", "prisma-app-client"]

    await Promise.all(
      builds.map(async (b) => {
        const {entry, out, format, isLambda} = b
        const context = await esbuild.context({
          entryPoints: [entry],
          bundle: true,
          outfile: out,
          platform: "node",
          target: "node18",
          packages: isLambda ? "bundle" : "external",
          external: isLambda ? ["aws-sdk"] : [...prismaExcludes],
          sourcemap: true,
          format,
          logLevel: "info",
          tsconfigRaw: tsconfig,
          metafile: generateMetafile,
        })
        // Do an initial build
        const result = await context.rebuild()
        if (generateMetafile) {
          fs.writeFileSync(
            `${out}.metafile.json`,
            JSON.stringify(result.metafile, null, 2)
          )
        }
        const isWatchMode = false
        if (isWatchMode) {
          // Watch for code changes
          await context.watch()
        } else {
          context.dispose()
        }
      })
    )
  }
}

type EsbuildTarget = {
  entry: string
  out: string
  format: esbuild.Format
  isLambda?: boolean
}

type TsconfigJson = {
  compilerOptions: ts.CompilerOptions
  include?: string[]
  exclude?: string[]
}
