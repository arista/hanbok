#!/bin/bash

# Fail on command failure, undefined variables, and piped command failures
set -euo pipefail

BUILD_DATE=`date -u -Iseconds`
BUILD_UUID=`cat /proc/sys/kernel/random/uuid`

echo BUILD_DATE: ${BUILD_DATE}
echo BUILD_UUID: ${BUILD_UUID}
echo Hanbok source dir: ${CODEBUILD_SRC_DIR_Hanbok}
echo Suite source dir: ${CODEBUILD_SRC_DIR_Suite}
echo App source dir: ${CODEBUILD_SRC_DIR}
echo Suite name: ${SUITE_NAME}
echo App name: ${APP_NAME}
echo DEPLOYENV_PUBLISHED_ASSETS_S3_BASE: ${DEPLOYENV_PUBLISHED_ASSETS_S3_BASE}
echo DEPLOYENV_PUBLISHED_ASSETS_BASE: ${DEPLOYENV_PUBLISHED_ASSETS_BASE}

echo "Building hanbok"

cd $CODEBUILD_SRC_DIR_Hanbok
npm install
npm run build

echo "Building suite ${SUITE_NAME}"
cd $CODEBUILD_SRC_DIR_Suite

# Update package.json to point at the local copy of hanbok
jq --arg key "hanbok" \
   --arg val "file:$CODEBUILD_SRC_DIR_Hanbok" \
   '.dependencies[$key] = $val' \
   package.json > package.tmp.json && mv package.tmp.json package.json

npm install
npx hb build


echo "Building app ${APP_NAME}"
cd $CODEBUILD_SRC_DIR

# Update package.json to point at the local copies of hanbok and the
# suite
jq --arg key "hanbok" \
   --arg val "file:$CODEBUILD_SRC_DIR_Hanbok" \
   '.dependencies[$key] = $val' \
   package.json > package.tmp.json && mv package.tmp.json package.json

jq --arg key "$SUITE_NAME" \
   --arg val "file:$CODEBUILD_SRC_DIR_Suite" \
   '.dependencies[$key] = $val' \
   package.json > package.tmp.json && mv package.tmp.json package.json

# Build the app
npm install
npx hb build

# Go through each generated webapp
for dir in $CODEBUILD_SRC_DIR}/dist/webapps/*/; do
    WEBAPP_NAME=$(basename "$dir")
    echo "**** Deploying webapp: ${WEBAPP_NAME}"

    # Record the build info
    mkdir -p ${dir}/.buildInfo
    jq -n \
       --arg buildUuid "${BUILD_UUID}" \
       --arg suite "${SUITE_NAME}" \
       --arg app "${APP_NAME}" \
       --arg webapp "${WEBAPP_NAME}" \
       --arg deployenv "${DEPLOYENV}" \
       --arg codebuildBuildId "${CODEBUILD_BUILD_ID}" \
       --arg buildDate "${BUILD_DATE}" \
       --arg pipelineExecutionId "${PIPELINE_EXECUTION_ID:-}" \
       --arg publishedAssetsBase "${DEPLOYENV_PUBLISHED_ASSETS_BASE}/by-webapp/${WEBAPP_NAME}/site/" \
        --arg githubOwner_Hanbok "${GITHUB_OWNER_Hanbok:-}" \
        --arg githubRepo_Hanbok "${GITHUB_REPO_Hanbok:-}" \
        --arg gitCommitId_Hanbok "${GITHUB_COMMIT_ID_Hanbok:-}" \
        --arg gitBranch_Hanbok "${GITHUB_BRANCH_NAME_Hanbok:-}" \
        --arg githubOwner_Suite "${GITHUB_OWNER_Suite:-}" \
        --arg githubRepo_Suite "${GITHUB_REPO_Suite:-}" \
        --arg gitCommitId_Suite "${GITHUB_COMMIT_ID_Suite:-}" \
        --arg gitBranch_Suite "${GITHUB_BRANCH_NAME_Suite:-}" \
        --arg githubOwner_App "${GITHUB_OWNER_App:-}" \
        --arg githubRepo_App "${GITHUB_REPO_App:-}" \
        --arg gitCommitId_App "${GITHUB_COMMIT_ID_App:-}" \
        --arg gitBranch_App "${GITHUB_BRANCH_NAME_App:-}" \
       '{
    buildUuid: $ARGS.named.buildUuid,
    suite: $ARGS.named.suite,
    app: $ARGS.named.app,
    webapp: $ARGS.named.webapp,
    deployenv: $ARGS.named.deployenv,
    codebuildBuildId: $ARGS.named.codebuildBuildId,
    buildDate: $ARGS.named.buildDate,
    pipelineExecutionId: $ARGS.named.pipelineExecutionId,
    publishedAssetsBase: $ARGS.named.publishedAssetsBase,
    hanbokSource: (if ($ARGS.named.githubOwner_Hanbok | length > 0)
      then {
      githubOwner: $ARGS.named.githubOwner_Hanbok,
      githubRepo: $ARGS.named.githubOwner_Hanbok,
      commitId: $ARGS.named.gitCommitId_Hanbok,
      branch: $ARGS.named.gitBranch_Hanbok
      } else null end),
    suiteSource: (if ($ARGS.named.githubOwner_Suite | length > 0)
      then {
      githubOwner: $ARGS.named.githubOwner_Suite,
      githubRepo: $ARGS.named.githubOwner_Suite,
      commitId: $ARGS.named.gitCommitId_Suite,
      branch: $ARGS.named.gitBranch_Suite
      } else null end),
    appSource: (if ($ARGS.named.githubOwner_App | length > 0)
      then {
      githubOwner: $ARGS.named.githubOwner_App,
      githubRepo: $ARGS.named.githubOwner_App,
      commitId: $ARGS.named.gitCommitId_App,
      branch: $ARGS.named.gitBranch_App
      } else null end)
}' \
    > ${dir}/.buildInfo/buildInfo.json

    echo "Generated buildInfo.json:"
    cat ${dir}/.buildInfo/buildInfo.json

       # --arg buildUuid "${BUILD_UUID}" \
       # --arg suite "${SUITE_NAME}" \
       # --arg app "${APP_NAME}" \
       # --arg webapp "${WEBAPP_NAME}" \
       # --arg deployenv "${DEPLOYENV}" \
       # --arg codebuildBuildId "${CODEBUILD_BUILD_ID}" \
       # --arg buildDate "${BUILD_DATE}" \
       # --arg pipelineExecutionId "${PIPELINE_EXECUTION_ID}" \
       # --arg githubOwner "${GITHUB_OWNER}" \
       # --arg githubRepo "${GITHUB_REPO}" \
       # --arg gitCommitId "${GITHUB_COMMIT_ID}" \
       # --arg gitBranchName "${GITHUB_BRANCH_NAME}" \
       # > ${dir}/.buildInfo/buildInfo.json
    echo -n ${BUILD_UUID} > ${dir}/.buildInfo/buildUuid.txt

    # # Deploy the assets generated by vite
    # DEPLOY_BASE="s3://${PUBLIC_BUCKET_NAME}/webapp-assets/by-app/${APP_NAME}/by-deployenv/${DEPLOYENV}/by-webapp/${WEBAPP_NAME}"
    # echo "  **** Copying assets to ${DEPLOY_BASE}/site"
    # aws s3 cp --quiet ${dir}/ "${DEPLOY_BASE}/site/" --recursive --exclude ".vite/*" --exclude ".server/*" --exclude ".buildInfo" --exclude "index.html"

    # BUILD_INFO_BASE_KEY="webapp-builds/by-app/${APP_NAME}/by-deployenv/${DEPLOYENV}/by-webapp/${WEBAPP_NAME}"
    # BUILD_INFO_BASE="s3://${PRIVATE_BUCKET_NAME}/${BUILD_INFO_BASE_KEY}"
    # BUILD_INFO_DEST_DIR="${BUILD_INFO_BASE}/by-build-uuid/${BUILD_UUID}"
    # BUILD_INFO_DEST="${BUILD_INFO_DEST_DIR}/buildInfo.json"
    # echo "  **** Writing buildInfo.json to ${BUILD_INFO_DEST}"
    # aws s3 cp --quiet ${dir}/.buildInfo/buildInfo.json "${BUILD_INFO_DEST}"
    # MANIFEST_DEST="${BUILD_INFO_DEST_DIR}/manifest.json"
    # echo "  **** Writing manifest.json to ${MANIFEST_DEST}"
    # aws s3 cp --quiet ${dir}/.vite/manifest.json "${MANIFEST_DEST}"

    # # Record the build info indexes
    # INDEX_DESTS=(
    #     "${BUILD_INFO_BASE}/indexes/by-codebuild-build-id/${CODEBUILD_BUILD_ID}"
    #     "${BUILD_INFO_BASE}/indexes/by-build-date/${BUILD_DATE}"
    #     "${BUILD_INFO_BASE}/indexes/by-git-commit-id/${GITHUB_COMMIT_ID}"

    #     # This one effectively makes the build live, since the lambda
    #     # serving the site will likely be looking for the build at a
    #     # specific branch
    #     "${BUILD_INFO_BASE}/indexes/by-git-ref/${GITHUB_BRANCH_NAME}"
    # )

    # for index_dest in "${INDEX_DESTS[@]}"; do
    #     echo "  **** Writing buildUuid.txt to ${index_dest}"
    #     aws s3 cp --quiet ${dir}/.buildInfo/buildUuid.txt "${index_dest}"
    # done

    # # Deploy the lambda
    # echo "  **** Bundling webapp-lambda.zip"
    # LAMBDA_DIR="${PKGDIR}/dist/webapp-servers/${WEBAPP_NAME}/webapp-lambda"
    # # Bundle the build info with the lambda so it knows how to find
    # # the manifest, etc.
    # LAMBDA_BUILD_ARTIFACTS_DIR="${LAMBDA_DIR}/build-artifacts"
    # mkdir -p ${LAMBDA_BUILD_ARTIFACTS_DIR}
    # cp ${dir}/.vite/manifest.json ${LAMBDA_BUILD_ARTIFACTS_DIR}
    # cp ${dir}/.buildInfo/buildInfo.json ${LAMBDA_BUILD_ARTIFACTS_DIR}

    # # Copy the prisma build artifacts
    # mkdir -p ${LAMBDA_DIR}/node_modules
    # cp -r ${PKGDIR}/node_modules/@prisma/client ${LAMBDA_DIR}/node_modules
    # cp -r ${PKGDIR}/node_modules/prisma-app-client ${LAMBDA_DIR}/node_modules
    
    # # Zip up the lambda, copy to s3, deploy
    # cd ${LAMBDA_DIR}
    # zip -r ../webapp-lambda.zip *
    # LAMBDA_DEST_KEY="${BUILD_INFO_BASE_KEY}/server/webapp-lambda.zip"
    # LAMBDA_DEST="${PRIVATE_BUCKET_NAME}/${LAMBDA_DEST_KEY}"
    # echo "  **** Writing webapp-lambda.zip to ${LAMBDA_DEST}"
    # aws s3 cp ../webapp-lambda.zip "s3://${LAMBDA_DEST}"
    # # Update the lambda
    # AWS_LAMBDA_NAME="${APP_NAME}-webapp-${WEBAPP_NAME}-${DEPLOYENV}"
    # if aws lambda get-function --function-name "${AWS_LAMBDA_NAME}" > /dev/null 2>&1; then
    #     echo "  **** lambda function '${AWS_LAMBDA_NAME}' exists. Updating code from ${LAMBDA_DEST}..."
    #     aws lambda update-function-code --function-name "${AWS_LAMBDA_NAME}" --s3-bucket ${PRIVATE_BUCKET_NAME} --s3-key "${LAMBDA_DEST_KEY}"
    # else
    #     echo "  **** lambda function '${AWS_LAMBDA_NAME}' does not exist. Skipping update."
    # fi
done
